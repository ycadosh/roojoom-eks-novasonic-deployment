name: Deploy Pipecat to AWS (ECS/EKS)

on:
  push:
    branches:
      - main
      - develop
    paths:
      - '**'
      - '.github/workflows/deploy.yml'
  pull_request:
    branches:
      - main
    paths:
      - '**'
      - '.github/workflows/deploy.yml'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'test'
        type: choice
        options:
          - test
          - staging
          - prod
      deployment_type:
        description: 'Deployment platform'
        required: true
        default: 'ecs'
        type: choice
        options:
          - ecs
          - eks
      image_tag:
        description: 'Docker image tag'
        required: false
        default: 'latest'
        type: string
      skip_tests:
        description: 'Skip tests'
        required: false
        default: false
        type: boolean

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY_PREFIX: pipecat-voice-agent

jobs:
  # Test job - runs on all triggers
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    if: ${{ !inputs.skip_tests }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Run basic syntax checks
        run: |
          python -m py_compile *.py
          echo "‚úÖ Python syntax check passed"

      - name: Test Docker build
        run: |
          docker build -t pipecat-test:${{ github.sha }} .
          echo "‚úÖ Docker build test passed"

  # Determine deployment environment and settings
  setup:
    name: Setup Deployment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      image_tag: ${{ steps.env.outputs.image_tag }}
      should_deploy: ${{ steps.env.outputs.should_deploy }}
    
    steps:
      - name: Determine environment and settings
        id: env
        run: |
          # Determine environment based on trigger
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            ENVIRONMENT="${{ inputs.environment }}"
            IMAGE_TAG="${{ inputs.image_tag }}"
            SHOULD_DEPLOY="true"
          elif [ "${{ github.ref }}" = "refs/heads/main" ]; then
            ENVIRONMENT="prod"
            IMAGE_TAG="v${{ github.run_number }}"
            SHOULD_DEPLOY="true"
          elif [ "${{ github.ref }}" = "refs/heads/develop" ]; then
            ENVIRONMENT="staging"
            IMAGE_TAG="staging-${{ github.sha }}"
            SHOULD_DEPLOY="true"
          elif [ "${{ github.event_name }}" = "pull_request" ]; then
            ENVIRONMENT="test"
            IMAGE_TAG="pr-${{ github.event.number }}-${{ github.sha }}"
            SHOULD_DEPLOY="false"  # Only build, don't deploy for PRs
          else
            ENVIRONMENT="test"
            IMAGE_TAG="test-${{ github.sha }}"
            SHOULD_DEPLOY="false"
          fi
          
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "should_deploy=$SHOULD_DEPLOY" >> $GITHUB_OUTPUT
          
          echo "üöÄ Environment: $ENVIRONMENT"
          echo "üè∑Ô∏è Image tag: $IMAGE_TAG"
          echo "üì¶ Should deploy: $SHOULD_DEPLOY"

  # Build and push Docker image
  build:
    name: Build and Push Image
    runs-on: ubuntu-latest
    needs: [test, setup]
    if: always() && (needs.test.result == 'success' || needs.test.result == 'skipped')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push Docker image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ env.ECR_REPOSITORY_PREFIX }}-${{ needs.setup.outputs.environment }}
          IMAGE_TAG: ${{ needs.setup.outputs.image_tag }}
        run: |
          # Build image with metadata
          docker build \
            --build-arg BUILD_TIMESTAMP="$(date -u +"%Y-%m-%dT%H:%M:%SZ")" \
            --build-arg GIT_COMMIT="${{ github.sha }}" \
            --build-arg ENVIRONMENT="${{ needs.setup.outputs.environment }}" \
            --build-arg GITHUB_RUN_ID="${{ github.run_id }}" \
            --tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            --tag $ECR_REGISTRY/$ECR_REPOSITORY:latest \
            .
          
          # Push images
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          
          echo "‚úÖ Image pushed successfully"
          echo "üì¶ Image URI: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

  # Deploy to ECS (only for main/develop branches or manual dispatch)
  deploy:
    name: Deploy to ECS
    runs-on: ubuntu-latest
    needs: [build, setup]
    if: needs.setup.outputs.should_deploy == 'true'
    environment: ${{ needs.setup.outputs.environment }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy to ECS
        if: inputs.deployment_type == 'ecs' || inputs.deployment_type == ''
        env:
          ENVIRONMENT: ${{ needs.setup.outputs.environment }}
          IMAGE_TAG: ${{ needs.setup.outputs.image_tag }}
        run: |
          # Make scripts executable
          chmod +x scripts/deploy-service.sh
          
          # Deploy the service
          ./scripts/deploy-service.sh \
            --environment $ENVIRONMENT \
            --region ${{ env.AWS_REGION }} \
            --tag $IMAGE_TAG \
            --update

      - name: Deploy to EKS
        if: inputs.deployment_type == 'eks'
        env:
          ENVIRONMENT: ${{ needs.setup.outputs.environment }}
          IMAGE_TAG: ${{ needs.setup.outputs.image_tag }}
        run: |
          # Install kubectl
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/
          
          # Configure kubectl
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name pipecat-eks-cluster-$ENVIRONMENT
          
          # Create namespace if it doesn't exist
          kubectl create namespace pipecat --dry-run=client -o yaml | kubectl apply -f -
          
          # Update image in deployment manifest and apply
          sed -i "s|image: .*|image: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY_PREFIX }}-$ENVIRONMENT:$IMAGE_TAG|" pipecat-phone-service.yaml
          kubectl apply -f pipecat-phone-service.yaml -n pipecat
          
          # Wait for rollout
          kubectl rollout status deployment/pipecat-phone-service -n pipecat --timeout=300s

      - name: Get deployment status
        env:
          ENVIRONMENT: ${{ needs.setup.outputs.environment }}
        run: |
          CLUSTER_NAME="pipecat-cluster-$ENVIRONMENT"
          SERVICE_NAME="pipecat-service-$ENVIRONMENT"
          
          # Get service status
          SERVICE_STATUS=$(aws ecs describe-services \
            --cluster $CLUSTER_NAME \
            --services $SERVICE_NAME \
            --region ${{ env.AWS_REGION }} \
            --query 'services[0].[runningCount,pendingCount,desiredCount]' \
            --output text)
          
          RUNNING_COUNT=$(echo $SERVICE_STATUS | cut -f1)
          PENDING_COUNT=$(echo $SERVICE_STATUS | cut -f2)
          DESIRED_COUNT=$(echo $SERVICE_STATUS | cut -f3)
          
          echo "üìä Service Status:"
          echo "  Running tasks: $RUNNING_COUNT"
          echo "  Pending tasks: $PENDING_COUNT"
          echo "  Desired tasks: $DESIRED_COUNT"
          
          # Get load balancer URL
          STACK_NAME="PipecatEcsStack-$ENVIRONMENT"
          ALB_DNS=$(aws cloudformation describe-stacks \
            --stack-name $STACK_NAME \
            --region ${{ env.AWS_REGION }} \
            --query 'Stacks[0].Outputs[?OutputKey==`LoadBalancerDnsName`].OutputValue' \
            --output text 2>/dev/null || echo "Not available")
          
          if [ "$ALB_DNS" != "Not available" ]; then
            echo "üåê Application URL: http://$ALB_DNS"
            echo "APPLICATION_URL=http://$ALB_DNS" >> $GITHUB_ENV
          fi

      - name: Create deployment summary
        run: |
          echo "## üöÄ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ needs.setup.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Image Tag**: ${{ needs.setup.outputs.image_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Git Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployment Time**: $(date -u)" >> $GITHUB_STEP_SUMMARY
          
          if [ -n "$APPLICATION_URL" ]; then
            echo "- **Application URL**: $APPLICATION_URL" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üìã Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "1. Verify the application is running at the URL above" >> $GITHUB_STEP_SUMMARY
          echo "2. Check CloudWatch logs for any issues" >> $GITHUB_STEP_SUMMARY
          echo "3. Monitor ECS service health in AWS Console" >> $GITHUB_STEP_SUMMARY

  # Notification job (runs after deployment)
  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: [setup, build, deploy]
    if: always() && needs.setup.outputs.should_deploy == 'true'
    
    steps:
      - name: Notify deployment status
        run: |
          if [ "${{ needs.deploy.result }}" = "success" ]; then
            echo "‚úÖ Deployment to ${{ needs.setup.outputs.environment }} completed successfully!"
          else
            echo "‚ùå Deployment to ${{ needs.setup.outputs.environment }} failed!"
            exit 1
          fi